# Collections

## Задание 1.
Проводилось сравнение времени работы основных операций для собственной реализации двусвязного списка MyLinkedList и java-реализации LinkedList. Были получены следующие результаты: удаление элементов из списка стабильно быстрее в собственной реализации, результаты добавления элементов и поиска изменяются при разных запусках программы. При небольшом количестве элементов в среднем по двум показателям из трех собственная реализация выигрывает. При увеличении количества элементов собственная реализация заметно обходит java-реализацию.
Гистограмма ниже демонстирует сравнение времени выполнения рассмотренных операций для MyLinkedList и LinkedList для 50000 элементов в списке и при добавлении 1000 элементов.

![1_1](https://user-images.githubusercontent.com/54889938/143435691-a35e9007-001e-4d51-9b39-52508269fcb7.jpg)

## Задание 2.
### 2.1 ArrayList vs LinkedList
Были рассмотрены ArrayList и LinkedList и сравнивались операции добавления элементов, вставки в начало и середину, поиска и удаления элементов из середины и начала. Результаты добавления при разном количестве добавляемых элементов (100, 500, 1000) представлены на диаграмме ниже. Из нее следует, что при большом количестве добавляемых элементов лучше использовать ArrayList, а также для вставки элементов в середину списка. Если говорить о вставке одного элемента, то LinkedList одерживает победу, т.к. сложность такого алгоритма О(1) против O(n) у ArrayList.

![2add](https://user-images.githubusercontent.com/54889938/143435799-57bde761-019d-4b61-9ad7-213b2ac29e6d.jpg)

для вставки элементов же в начало списка быстрее работает LinkedList. Аналогично для удаления элементов: удаление из начала быстрее у LinkedList,
из конца - у ArrayList. Поиск элемента примерно одинаковый по времени.

В целом асимптотическая сложность ряда алгоритмов представлена ниже таблицей:

|                             |  ArrayList  |  LinkedList |
| --------------------------- | ---------- | ----------- |
| add (в начало)              |     O(n)    |   O(1)
| add (в середину)            |     O(n)    |   O(n)
| add (в конец списка)        |     O(n)    |   O(1)   
| get (первый элемент)        |     O(1)    |   O(1)
| get (из середины)           |     O(1)    |   O(n)
| get (последний элемент)     |     O(1)    |   O(1)
| remove (первый элемент)     |     O(n)    |   O(1)
| remove (из середины)        |     O(n)    |   O(n)
| remove (последний элемент)  |     O(1)    |   O(1)


### 2.2 HashSet vs LinkedHashSet vs TreeSet 
HashSet реализован на основе хеш-таблицы, а TreeSet – на основе бинарного дерева, в LinkedHashSet сохраняется порядок вставки элементов. HashSet гораздо быстрее чем TreeSet (константное время против логарифмического для большинства операций, таких как add, remove, contains), но TreeSet гарантирует упорядоченность объектов. Экспериментально было получено, что добавление эффективнее у HashSet. С удалением лучше справился LinkedHashSet. Поиск элементов примерно одинаков у HashSet и LinkedHashSet. TreeSet проигрывает по производительности в силу дополнительных проверок из-за упорядоченности элементов.

### 2.3 HashMap vs LinkedHashMap vs TreeMap 
HashMap не дает никаких гарантий относительно порядка элементов, он изменяется при добавлении новых элементов. LinkedHashMap сохраняет элементы в порядке добавления в Map. У TreeMap в соответствии с порядком возрастания ключа при обходе (сравнение с помощью метода compareTo ключа). По производительности ситуация похожа на предыдущй пункт. Добавление быстрее у HashMap. Поиск и удаление - LinkedHashMap/HashMap. Удаление элементов дольше всего у TreeMap.

